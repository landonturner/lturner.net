<!doctype html>
<html>
  <head>

    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Building This Blog</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="/assets/app.css">
    <script src="/assets/app.js"></script>
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col markdown-body">
          <h1 id="building-this-blog">Building This Blog</h1>
<p>There are many blogging platforms that are great and easy to use. However, I
like to have more direct control over the source files, and I want my blog to
live under my own domain name. Another requirement for this project is that
each subsequent post should be easy to create. Finally, I need to be able to
see my changes reflected quickly in the browser. This post will detail how to
setup a dev environment to generate such a blog.</p>
<p>Each individual post in the blog we will make will be a simple
<a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> file that gets translated
into a fully formed html page using <a href="https://metalsmith.io/">Metalsmith</a>. The
html file then can be served directly over the internet.</p>
<p>I will walk through each technical design decision I have made, and if you
follow these steps (or just fork <a href="">the repo</a>) you will have an efficient way
to administer your highly customizable blog. I will not go into UI and specific
styling choices as I think those are best left UI/UX experts. If you are a
UI/UX expert, I would love to hear comments on how I did.</p>
<p>I have all the code sitting in <a href="https://github.com/landonturner/metalsmith-blog-seed">this github
repo</a>. Feel free to bug
me about any errors or issues there.</p>
<h2 id="project-setup">Project Setup</h2>
<p>Use <code>npm init</code> to create your base project. The choices you make don&#39;t really
make that much of a difference as far as this post is concerend. I like the
styling on the airbnb eslint, so that is what I have included in the
<code>.eslintrc.yml</code> file. I personally use <a href="https://github.com/w0rp/ale">vim ale</a>
to keep my project linted and fresh during development. That is outside the
scope of this post, however. You can skip all the linting if you are a complete
savage.</p>
<h3 id="modern-javascript--babel">Modern Javascript &amp; Babel</h3>
<p>I prefer the newer javascript syntax. Arrows, async/await, consts etc. Out of
the box node does not like this syntax so I use the <a href="https://babeljs.io/">babel
transpiler</a> to convert the newer javascript into plain
javascript. Our main file is somewhat small, so skipping this completely and
using the older require syntax will be completely fine, just be warned you will
have to change main.js to suit your own needs.</p>
<p>Install babel with the following npm commands</p>
<pre><code>npm install --save-dev @babel/cli @babel/core @babel/node @babel/polyfill @babel/preset-env</code></pre><p>Create a file named <code>babel.config.js</code> in your root directory add the following:</p>
<pre><code class="language-javascript">// bable.config.js
module.exports = { presets: [&#39;@babel/env&#39;] };</code></pre>
<p>Create a <code>main.js</code> file in your root directory and dump in your favorite
javascript hello world as a placeholder. To demonstrate how babel transpiles
the code, you can run <code>./node_modules/.bin/babel main.js</code> from the command
line. This will display on your console your main.js file converted to plain
javascript. Kind of neat but not really that useful. Our <code>@babel/node</code>
dependency provided us a program called <code>babel-node</code> that will transpile <em>and</em>
run our code. Much more useful. Running <code>./node_modules/.bin/babel-node
main.js</code> will execute our main.js file. I find it tedious to run that command
by hand each time, so I added a script into the package.json like this:</p>
<pre><code>  ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;babel-node main.js&quot;
  },
  ...</code></pre><p>This works because npm has the superpower that it is aware of executibles
located in node-modules/.bin. You can run your project with <code>npm run build</code>
now.</p>
<h3 id="structure">Structure</h3>
<p>Here is what my directory structure looks like</p>
<pre><code>$ tree -I node_modules -a
.
|-- .eslintrc.yml
|-- babel.config.js
|-- main.js
|-- package-lock.json
`-- package.json</code></pre><p>At this point, we have our environment configured to run everything we want to
run. There is still one more piece for expedient development.</p>
<h3 id="rebuilding-automatically">Rebuilding Automatically</h3>
<p>It seems pretty obvious to me why rebuilding your project automatically would
be useful. There is a tool called <a href="https://github.com/remy/nodemon">nodemon</a>
that will watch your filesystem and run a command whenever it detects a file
has been changed. We can configure it to watch all our markdown, layout, js, and
style files and rebuild the site for us.</p>
<pre><code>npm install --save-dev nodemon</code></pre><p>Add this script into your package.json</p>
<pre><code>&quot;watch&quot;: &quot;nodemon --watch source --watch layouts -e md,scss,hbs,js ./node_modules/.bin/babel-node main.js&quot;</code></pre><p>Start watching and rebuilding automoatically with <code>npm run watch</code>. Now if you
change file ending in <code>md</code>, <code>scss</code>, <code>hbs</code>, or <code>js</code> your project will rebuild
itself.</p>
<h2 id="metalsmith">Metalsmith</h2>
<p>Metalsmith bills itself as a simple, pluggable site generator. There are a lot
of cool things you can do with metalsmith. For example,
<a href="https://mapr.com">MapR</a> uses metalsmith to build their entire public facing
marketing site. I like to think of metalsmith as a pipeline. Each stage of the
pipeline is a plugin that does a specific task. Usually the plugins mutate the
contents of a file into another form. The mutated files are then written out
the the destination folder. With no plugins at all the destination folder looks
exactly like the source folder. The first plugin <code>metalsmith-markdown</code> we will
introduce will translate the markdown into raw html.</p>
<pre><code>npm install --save metalsmith metalsmith-markdown</code></pre><h3 id="translating-markdown-to-html">Translating Markdown to HTML</h3>
<p>First create a folder to store all the markdown files. I&#39;m calling mine
<code>source</code>. Add in a markdown file. Here is an example if you are feeling
uncreative. The folder name will become the URL link because the <code>index.html</code>
part is served by default.</p>
<pre><code class="language-markdown">&lt;!-- ./source/awesome-blog-post/index.md --&gt;
# This is a terrible blog post

with unimaginative language
and boring word structure

### but the content is

[top notch](https://thenumbersnail.com)
[a one](https://leaveanote.io/oldtownbrown)</code></pre>
<pre><code class="language-javascript">// main.js
import Metalsmith from &#39;metalsmith&#39;;
import markdown from &#39;metalsmith-markdown&#39;;

Metalsmith(__dirname)
  .source(&#39;./source&#39;) // use source as the starting folder
  .destination(&#39;./dist&#39;) // output resulting files to ./dist
  .clean(false) // do not remove files from dist on each build

  .use(markdown()) // translates markdown to html

  .build((err) =&gt; {
    if (err) throw err;
  });</code></pre>
<p>Run it with <code>npm run build</code>. It should run without errors and produce our html
file in the newly created <code>dist</code> folder.</p>
<pre><code>$ tree -I node_modules
.
|-- babel.config.js
|-- dist
|   `-- blog
|       |-- awesome-blog-post
|       |   |-- index.html
|       `-- creating-a-blog
|           |-- index.html
|-- layouts
|   `-- blog-post.hbs
|-- main.js
|-- package-lock.json
|-- package.json
`-- source
    `-- blog
        |-- awesome-blog-post
        |   `-- index.md
        `-- creating-a-blog
            `-- index.md</code></pre><p>You could probably guess for every markdown file in the source directory, a
corresponding html page will be created in the dist folder. It will even
respect the folder structure. I&#39;m going to move all my blog posts under
<code>/blog</code>.</p>
<p>Inspecting these files and they are html, but they are just fragments; there
are no top level <code>&lt;html&gt;</code> tags and lack html best practices. Lets fix that with
metalsmith-layouts!</p>
<h3 id="building-fully-formed-pages---layouts">Building Fully Formed Pages - Layouts</h3>
<p>Layouts helps frame our html in an html document. There are many templating
language you can pick. I picked handlebars becasue I have some experience with
it. There are plenty of good ones out there, so if you hate handlebars feel
free to pick something else.</p>
<p>Install the layout and the jstransformer (handlebars) with these commands:</p>
<pre><code class="language-bash">npm install --save metalsmith-layouts
npm install --save-dev jstransformer-handlebars</code></pre>
<p>I try to install things that I import directly in my project as dependencies
(metalsmith, markdown, layouts, etc) and background packages (nodemon, babel,
jstransformers, etc) into dev dependencies.</p>
<p>Lets wrap our awesome blog post in html. Create a folder named <code>layouts</code> and
start writing our handlebars template. We have two fields here that we will
address in a moment in our markdown file. Notice that content has three
curlies, because we do not want the content HTML encoded. The title should be
html encoded, so we use two curlies.</p>
<pre><code class="language-html">{{!-- layouts/blog-post.hbs --}}
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {{{ contents }}}
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>In metalsmith, <code>contents</code> refers to the body of the document. It started as
markdown, and then the markdown plugin converted it to html, and now we are
going to insert it into this blog post template. For more information on how
metalsmith works under the hood, check out the <a href="https://metalsmith.io/#how-does-it-work-in-more-detail-">metalsmith
documentation</a></p>
<p>We can add metadata to each file using
[frontmatter]<a href="https://middlemanapp.com/basics/frontmatter/">https://middlemanapp.com/basics/frontmatter/</a>) located at the start
of the markdown. The metadata we add is exposed to each plugin, and we can use
it in our layout. The <code>{{ title }}</code> expression in the layout file will be
populated from our frontmatter.</p>
<p>Certain plugins look for specific metadata in the frontmatter. The layouts
plugin needs to know which layout to use. You can set a default layout when you
initialize the plugin, but I have chosen to specify the layout in the
frontmatter.</p>
<pre><code class="language-markdown">---
title: Awesome Blog Post
layout: blog-post.hbs
---
&lt;!-- ./source/awesome-blog-post/index.md --&gt;
...</code></pre>
<p>And to put it all together, initialize the layouts in main.js. You must include
the layouts after markdown, so that we are templating the content <em>after</em> we
transformed it into html.</p>
<pre><code class="language-javascript">// main.js
import Metalsmith from &#39;metalsmith&#39;;
import markdown from &#39;metalsmith-markdown&#39;;
import layouts from &#39;metalsmith-layouts&#39;;

Metalsmith(__dirname)
  .source(&#39;./source&#39;)
  .destination(&#39;./dist&#39;)
  .clean(false)

  .use(markdown())
  .use(layouts()) // embeds the content in the handlebars layout

  .build((err) =&gt; {
    if (err) throw err;
  });</code></pre>
<p>Running this now will produce a fullly formed html document! Open it in your
favorite browser and look at it. Its ugly, but it&#39;s unfortunately your baby, so
you have to love it. Protip the command <code>open .</code> on a mac will open the current
folder in finder. </p>
<h2 id="nginx">Nginx</h2>
<p>You should make sure you have <a href="https://www.docker.com/">docker</a> and
docker-compose installed on your machine. I find this the easiest way to run
nginx for development purposes.</p>
<p>You can open this file in your browser just fine, but in our next section, we
are going to need to reference other files on a relative basis (css styles, and
js sources), so we are going to need some way to serve up our site during
development. We should get a basic nginx container working with docker so we
can continue to chug along. Docker makes this all very simple. In a file
named <code>docker-compose.yml</code>, dump the following yaml:</p>
<pre><code class="language-yaml"># docker-compose.yml
nginx:
  image: nginx
  container_name: blag-nginx
  volumes:
    - ./dist/:/usr/share/nginx/html
  ports:
    - 80:80</code></pre>
<p>Start it with <code>docker-compose up</code>. You have a server! The nice thing about
doing it this way is that because the dist folder is mounted in the container
as a volume, any changes are instantly reflected. navigate to
<a href="http://127.0.0.1/blog/awesome-blog-post">http://127.0.0.1/blog/awesome-blog-post</a> and you can view your <em>beautiful</em> blog
post. A further improvement here would be for live reloading on the browser
whenever something has changed. <code>webpack-dev-server</code> has this functionality but
I have not looked into integrating this yet.</p>
<h3 id="styling-and-javascript">Styling and Javascript</h3>
<p>Let&#39;s put some lipstick on this pig. First we are going to make a site-wide
scss file that should be included in each page. I like scss because I&#39;m not a
psychopath who enjoys tortuing myself with vanilla css. We don&#39;t have anything
that transforms css in our metalsmith pipeline at the moment, so if we were to
put a scss file in source, it would appear as a regular scss file in our dist.
There are handy plugins to do this conversion for us. Similarily, we will use a
metalsmith-babel plugin to take care of translating modern js into browser
friendly js.</p>
<p>The examples just contain some dummy data for example purposes.</p>
<pre><code>npm install --save metalsmith-sass metalsmith-babel</code></pre><pre><code class="language-js">// source/assets/app.js
const square = x =&gt; x * x;
square(123);</code></pre>
<pre><code class="language-scss">// source/assets/app.scss
body {
  pre {
    background-color: black;
    color: white;
  }
}</code></pre>
<p>To make load them in the html I am going to add them to the layout.</p>
<pre><code class="language-html">{{!-- layouts/blog-post.hbs --}}
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{ title }}&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/app.css&quot;&gt;
    &lt;script src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {{{ contents }}}
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>To enable these add the following to your main.js. These plugins do not depend
on any plugins before or after, so it does really matter where you include this
in your metalsmith call chain.</p>
<pre><code class="language-javascript">// main.js
import Metalsmith from &#39;metalsmith&#39;;
import markdown from &#39;metalsmith-markdown&#39;;
import layouts from &#39;metalsmith-layouts&#39;;
import sass from &#39;metalsmith-sass&#39;;
import babel from &#39;metalsmith-babel&#39;;

Metalsmith(__dirname)
  .source(&#39;./source&#39;)
  .destination(&#39;./dist&#39;)
  .clean(false)

  .use(markdown())
  .use(layouts())

  .use(sass()) // converts scss -&gt; css
  .use(babel()) // converts modern js -&gt; classic js

  .build((err) =&gt; {
    if (err) throw err;
  });</code></pre>
<p>From this point you have a prety solid setup to create your html pages. Every
new blog post can easily created adding another markdown file and rebuilding.
Add in another template for your main page and you have yourself a website! If
you want help making this site not look like trash, you&#39;re going to probably
have to do what I am about to do and spend hours tweaking it. </p>
<h2 id="production-build">Production Build</h2>
<p>Sometimes you want to include things in your html that is only meant for
production. <em>cough cough Google Analytics cough cough</em> Using if statements in
handlebars and providing an metadata flag in metlasmith will easily allow us to
only inlcude things only meant for production production build.</p>
<p>Metalsmith has a metadata method that provides each file with arbitrary
information. We can use this to include a flag that indicates if we are in a
production build.</p>
<pre><code class="language-javascript">// main.js

...


Metalsmith(__dirname)
...
// main.js
import Metalsmith from &#39;metalsmith&#39;;
import markdown from &#39;metalsmith-markdown&#39;;
import layouts from &#39;metalsmith-layouts&#39;;
import sass from &#39;metalsmith-sass&#39;;
import babel from &#39;metalsmith-babel&#39;;

const production = process.env.NODE_ENV === &#39;production&#39;;

Metalsmith(__dirname)
  .source(&#39;./source&#39;)
  .destination(&#39;./dist&#39;)
  .clean(false)

  .metadata({ production }) // adds { producion: true } in metadata of
                            // all files during production builds
  .use(markdown())
  .use(layouts())

  .use(sass())
  .use(babel())

  .build((err) =&gt; {
    if (err) throw err;
  });</code></pre>
<p>I am going to modify the build script in <code>package.json</code> a bit to include the
environment. The watch script will build the project for development, and the
build script will produce the final output.</p>
<pre><code>&quot;build&quot;: &quot;NODE_ENV=production babel-node main.js&quot;,</code></pre><h3 id="adding-production-html">Adding Production HTML</h3>
<p>In our template we can wrap our google analyitcs tag in an if statment</p>
<pre><code>{{!-- layouts/blog-post.hbs --}}
    {{#if production}}
    &lt;div&gt;GOOOOOOGLE ANNNNNNNALYITCS&lt;/div&gt;
    {{/if}}</code></pre><p>Now running an <code>npm run build</code> will mark that it is a production build.</p>
<h2 id="deployment">Deployment</h2>
<p>There are plenty of great ways to deploy a static site. Honestly, you should
probably just deploy it using <a href="https://www.netlify.com">Netlify</a> #not-an-ad.
It&#39;s free for one user and if you are only running the static pages created
here its probably worth saving yourself the headache of administering your own
setup. I was going to try to self host this blog, but netlify looks pretty
great and I am going to use that instead.</p>

        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
